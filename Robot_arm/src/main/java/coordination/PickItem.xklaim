package xklaim.coordination

import coordination.JointTrajectory
import ros.Publisher
import ros.RosBridge
import ros.SubscriptionRequestMsg

proc PickItem(String rosbridgeWebsocketURI) {	
	// create the bridge and connect it to the ROS bridge
	val bridge = new RosBridge()
	bridge.connect(rosbridgeWebsocketURI, true)
	
	// initialize a publisher for the topic related to the control of the movements of the arm robot 
	val pub = new Publisher("/arm_controller/command", "trajectory_msgs/JointTrajectory", bridge)

	// set joint positions for performing the first movement of the arm
	val trajectoryPositions = #[-3.14, -0.2169, -0.5822, 3.14, 1.66, -0.01412]
	val JointTrajectory firstMovement = new JointTrajectory()
		.positions(trajectoryPositions)
		.jointNames(#[
			"joint1", "joint2", "joint3", "joint4", "joint5", "joint6"
		]);
	// publishing the joint trajectory
	pub.publish(firstMovement)
	
	// subscribe to get the actual status of the arm 
	bridge.subscribe(
		SubscriptionRequestMsg.generate("/arm_controller/state").setType("control_msgs/JointTrajectoryControllerState").
			setThrottleRate(1).setQueueLength(1), [ data, stringRep |
			// extract the position joints from the arm's status	
			val actual = data.get("msg").get("actual").get("positions")
		
			var sum = 0.0
			for (var i = 0; i < trajectoryPositions.size; i++) {
				sum += Math.abs(actual.get(i).asDouble() - trajectoryPositions.get(i))
			}
			// this is the error to  measure the completeness of the first action "before pick" 	
			// val norm = Math.sqrt(sum);		
			val tol = 0.000001

			if (sum <= tol) {
				// if the robot finish the first action, should perform the second action "pick"
				
				
				/////// userei il coordinamento con tuple qui: secondo me i controlli qui sopra li dovrebbe 
				/////// fare Before_Pick, perchÃ© chi fa l'azione dice quando ha finito. Lo dice pubblicando
				/////// una tupla localmente. Quindi Pick non fa altro che aspettare con una in che Before_Pick
				/////// abbia terminato e poi pubblica l'azione. 
				/////// Il vantaggio e' quello di poter disaccoppiare meglio il codice delle varie azioni, 
				/////// consentendo il riuso di questi processi.
				/////// ATTENZIONE: in caso tutti i processi andrebbero modificati in questo modo
				
				val pub2 = new Publisher("/arm_controller/command", "trajectory_msgs/JointTrajectory", bridge) 
				 
				val JointTrajectory pick = new JointTrajectory()
					.positions(#[
						-3.1415, -0.9975, -0.4970, 3.1400, 1.6613, -0.0142
					])
					.jointNames(#[
						"joint1", "joint2", "joint3", "joint4", "joint5", "joint6"
					]);
				pub2.publish(pick)
				
				
			}
		]
	)
}
