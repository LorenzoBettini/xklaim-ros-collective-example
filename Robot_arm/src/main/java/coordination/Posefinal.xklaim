package xklaim.coordination

import ros.RosBridge
import ros.Publisher
import ros.SubscriptionRequestMsg
import java.util.List
import java.util.Arrays
import coordination.JointTrajectoryPoint
import coordination.JointTrajectory

proc Posefinal(Locality robot2) {
	val myself=self
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"
	// Create the bridge and connect it to the ROS bridge
	val bridge = new RosBridge()
	bridge.connect(rosbridgeWebsocketURI, true)

	// Initialize a publisher for the topic related to the control of the robot's arm
        val  pub = new Publisher("/arm_controller/command", "trajectory_msgs/JointTrajectory", bridge);
		bridge.subscribe(
		SubscriptionRequestMsg.generate("/arm_controller/state").setType("control_msgs/JointTrajectoryControllerState").
			setThrottleRate(1).setQueueLength(1), [ data, stringRep |	
			val actual = data.get("msg").get("actual").get("positions");
	        val List<Double> desire = Arrays.asList(-0.9546 , -0.20,   -0.7241,  3.1400, 1.6613, -0.0142);
		   	var sum = 0.0; 
            for (var i =0; i< 6; i=i+1){
            	//sum = sum + Math.pow(error.get(i).asDouble()-desire.get(i),2.0);
                sum = sum + Math.pow(actual.get(i).asDouble()-desire.get(i),2.0);}           	      
            val norm = Math.sqrt(sum);            
           	val tol = 0.008;	
	 if (norm <= tol) {
		   			out("goto1", "world",-0.24, -2.67, 1.0)@robot2  
		   // here when the robot send message arrived, the arm should pose the object.
            
      in("arrived", var String arrived)@myself
      println(String.format("I am: %s,", arrived))
            val jointTrajectoryPoints = new JointTrajectoryPoint();
            jointTrajectoryPoints.positions = Arrays.asList(-0.9546 , -0.0097,   -0.9513,  3.1400, 1.7749, -0.0142); 
            //jointTrajectoryPoints.velocities=velocities;
            jointTrajectoryPoints.time_from_start.nsecs=0;
            jointTrajectoryPoints.time_from_start.secs=120;
            // JointTrajectory Initialization
            val JointTrajectory posefinal = new JointTrajectory();
         //   val pointtraject = new JointTrajectoryPoint[]; 
            var List<JointTrajectoryPoint> list = Arrays.asList(jointTrajectoryPoints);
            posefinal.points = list;     
            posefinal.joint_names = Arrays.asList( "joint1", "joint2", "joint3", "joint4", "joint5", "joint6");
            posefinal.header.stamp.secs=0;
            posefinal.header.stamp.nsecs=0;
            posefinal.header.frame_id = "";            
		    pub.publish(posefinal);
		    println(String.format("Iam posing"))	
		    bridge.unsubscribe("/arm_controller/state");	    
		  }  
		    ])
}







