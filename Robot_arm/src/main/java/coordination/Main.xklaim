package xklaim.coordination 
import ros.RosBridge

net RobotColl physical "localhost:9999" {
	node Arm {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"
		// Create the bridge and connect it to the ROS bridge
		val bridge = new RosBridge()
		bridge.connect(rosbridgeWebsocketURI, true)
		
		/////// si potrebbe creare qui il bridge, magari con un metodo per nascondere qualche info
		/////// val bridge = Init()
		/////// si potrebbe mettere l'uri come parametro di Init oppure leggere queste info da file .properties ??? 
		
		/////// Non mi e' chiara la differenza fra Before_Pick e Pick, forse la prima Ã¨ solo 
		/////// una rotazione e la seconda piega il braccio??? 
		/////// se e' cosi' allora ha senso tenere separate le due azioni, in vista della estensione dello scenario  
		/////// perche' la rotate cambia mentre le altre azioni restano le stesse. 
		
		/////// Before_pick -> Rotate??? MoveTowardsItem
		executeNodeProcess(new Before_pick(bridge))
		/////// Pick -> PickItem
		executeNodeProcess(new Pick(bridge))
		
		
		
		/////// Grasp-> GripItem???
		executeNodeProcess(new Grasp())
		
		/////// After_pick -> LiftItem ??? oltre a tirare su ruota?
		executeNodeProcess(new After_pick())
		
		/////// Capire cosa fa Pose(); ruota e basta?
		executeNodeProcess(new Pose())
		
		////// Pose -> Put down
		
		/////// Pose final chiama l'altro robot e inizia a posare: facciamo un processo solo per questa chiamata? 
		executeNodeProcess(new Posefinal(Robot2))
		
		//// OpenGripper -> ReleaseItem
		executeNodeProcess(new OpenGripper(Robot2))
		
		/// capire bene cosa fa....
		executeNodeProcess(new Afterpose(Robot2))
	}
	node Robot2 {
		executeNodeProcess(new Moveto(Arm))
		executeNodeProcess(new GiveObject())
	}
}
