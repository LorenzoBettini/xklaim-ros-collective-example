package xklaim.coordination

import coordination.JointTrajectory
import klava.Locality
import ros.Publisher
import ros.RosBridge
import ros.SubscriptionRequestMsg

proc Lay(String rosbridgeWebsocketURI,Locality robot2) {
	val myself = self

	// Create the bridge and connect it to the ROS bridge
	val bridge = new RosBridge()
	bridge.connect(rosbridgeWebsocketURI, true)

	// Initialize a publisher for the topic related to the control of the robot's arm
	val pub = new Publisher("/arm_controller/command", "trajectory_msgs/JointTrajectory", bridge);
	bridge.subscribe(
		SubscriptionRequestMsg.generate("/arm_controller/state").setType("control_msgs/JointTrajectoryControllerState").
			setThrottleRate(1).setQueueLength(1),
		[ data, stringRep |
			val actual = data.get("msg").get("actual").get("positions");
			val desire = #[-0.9546, -0.20, -0.7241, 3.1400, 1.6613, -0.0142];
			var sum = 0.0;
			for (var i = 0; i < 6; i = i + 1) {
				sum += Math.pow(actual.get(i).asDouble() - desire.get(i), 2.0);
			}
			val norm = Math.sqrt(sum);
			val tol = 0.008;
			if (norm <= tol) {
				out("goto1", "world",-0.25, -2.67, 1.0)@robot2
				// here when the robot send message arrived, the arm should pose the object.
				in("arrived", var String arrived)@myself
				println(String.format("I am: %s,", arrived))
				val JointTrajectory posefinal = new JointTrajectory().positions(#[
					-0.9546,
					-0.0097,
					-0.9513,
					3.1400,
					1.7749,
					-0.0142
				]).jointNames(#[
					"joint1",
					"joint2",
					"joint3",
					"joint4",
					"joint5",
					"joint6"
				]);
				pub.publish(posefinal);
				println(String.format("Iam posing"))
				bridge.unsubscribe("/arm_controller/state");
			}
		]
	)
}
