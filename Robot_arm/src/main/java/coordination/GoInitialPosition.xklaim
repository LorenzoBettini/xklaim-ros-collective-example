package xklaim.coordination

import coordination.JointTrajectory
import klava.Locality
import ros.Publisher
import ros.RosBridge
import ros.SubscriptionRequestMsg

proc GoInitialPosition(String rosbridgeWebsocketURI,Locality robot2) {
	val myself = self
	
	// Create the bridge and connect it to the ROS bridge
	val bridge = new RosBridge()
	bridge.connect(rosbridgeWebsocketURI, true)
	
	in("opened")@myself
	println(String.format("ready to take the object"));
	// Initialize a publisher for the topic related to the control of the robot's arm
	val pub = new Publisher("/arm_controller/command", "trajectory_msgs/JointTrajectory", bridge);

	// subscribe to get the actual state of the robot's arms
	bridge.subscribe(
		SubscriptionRequestMsg.generate("/gripper_controller/state").setType(
			"control_msgs/JointTrajectoryControllerState").setThrottleRate(1).setQueueLength(1), [ data, stringRep |
			val error = data.get("msg").get("actual").get("positions");
			val desire = #[0.000, 0.000];
			var sum = 0.0;
			for (var i = 0; i <= 1; i = i + 1) {
				sum += Math.pow(error.get(i).asDouble() - desire.get(i), 2.0);
			}
			val tol = 0.0009;
			val norm = Math.sqrt(sum);
			if (norm <= tol) {
				// out("open", "gripper_opened")@robot2
				// give the position of the person to the robot. 
				// JointTrajectory Initialization performing the referent position
				val JointTrajectory afterPose = new JointTrajectory()
					.positions(#[
						0.000, 0.000, 0.000, 0.000, 0.000, 0.000
					])
					.jointNames(#[
						"joint1", "joint2", "joint3", "joint4", "joint5", "joint6"
					]);
				pub.publish(afterPose);
				out("give", "world", -6.0, -5.0, 1.0)@robot2
			}
		]
	)
}
