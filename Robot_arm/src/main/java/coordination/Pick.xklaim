package xklaim.coordination

import coordination.JointTrajectory
import java.util.Arrays
import java.util.List
import ros.Publisher
import ros.RosBridge
import ros.SubscriptionRequestMsg

proc Pick(RosBridge bridge) {
	// Initialize a publisher for the topic related to the control of the robot's arm
	val pub = new Publisher("/arm_controller/command", "trajectory_msgs/JointTrajectory", bridge);

	// subscribe to get the actual status of the arm 
	bridge.subscribe(
		SubscriptionRequestMsg.generate("/arm_controller/state").setType("control_msgs/JointTrajectoryControllerState").
			setThrottleRate(1).setQueueLength(1), [ data, stringRep |
			// Extract the position joints from the Json message	
			val actual = data.get("msg").get("actual").get("positions");
			// this is a list of the desire positions of the first action
			val List<Double> desire = Arrays.asList(-3.14, -0.2169, -0.5822, 3.14, 1.66, -0.01412);

			var sum = 0.0;
			for (var i = 0; i < 6; i = i + 1) {
				sum = sum + Math.abs(actual.get(i).asDouble() - desire.get(i));
			}
			// this is the error to  measure the completeness of the first action "before pick" 	
			// val norm = Math.sqrt(sum);		
			val tol = 0.000001;

			if (sum <= tol) {
				// if the robot finish the first action, should perform the second action "pick"
				
				
				/////// userei il coordinamento con tuple qui: secondo me i controlli qui sopra li dovrebbe 
				/////// fare Before_Pick, perchÃ© chi fa l'azione dice quando ha finito. Lo dice pubblicando
				/////// una tupla localmente. Quindi Pick non fa altro che aspettare con una in che Before_Pick
				/////// abbia terminato e poi pubblica l'azione. 
				/////// Il vantaggio e' quello di poter disaccoppiare meglio il codice delle varie azioni, 
				/////// consentendo il riuso di questi processi.
				/////// ATTENZIONE: in caso tutti i processi andrebbero modificati in questo modo
				
				 
				val JointTrajectory pick = new JointTrajectory()
					.positions(#[
						-3.1415, -0.9975, -0.4970, 3.1400, 1.6613, -0.0142
					])
					.jointNames(#[
						"joint1", "joint2", "joint3", "joint4", "joint5", "joint6"
					]);
				pub.publish(pick);
				bridge.unsubscribe("/arm_controller/state");
			}
		]
	)
}
